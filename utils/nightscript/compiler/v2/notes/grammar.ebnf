(*
NightScript Version 2 Reference Grammar
This is the reference EBNF (Extended Backus-Naur Form) grammar for NightScript
version 2. It is used as a reference for creating the hand-written recursive
descent parser, rather than as an input for a parser generator. Because of this,
the grammar may not be accurate.

The 'program' rule is the entry point for the grammar. Rules written in caps
case and terminal strings refer to tokens generated by the lexer. Whitespace and
comments do not produce tokens, and error tokens should be ignored by the
parser.
*)

program = { "meta" IDENTIFIER [ "=" ] expr [ ";" ] } { stmt } END_OF_FILE ;
stmt    = "{" { stmt } "}"
        | "if" expr stmt [ "else" stmt ]
        | "while" expr stmt
        | "do" stmt [ "while" expr [ ";" ] ]
        | "&" stmt (* Menu statement. *)
        | "|" LITERAL_STRING stmt (* Option statement. *)
        | expr [ ";" ]
        | string_stmt
        | "break" [ ";" ]
        | "continue" [ ";" ]
        | "define" IDENTIFIER [ "=" ] expr [ ";" ]
        | "const" IDENTIFIER [ "=" ] expr [ ";" ]
        | "exit" [ ";" ]
        | "call" LITERAL_STRING [ ";" ]
        | "run" LITERAL_STRING [ ";" ]
        | "quit" [ ";" ]
        | "pause" [ ";" ]
        | "unpause" [ ";" ]
        | "save" [ ";" ]
        | "checkpoint" [ ";" ]
        | "~>" (* Run actor paths. *)
        | "->" (* Run actor paths and await. *)
        | "~" (* Await actor paths. *)
        | ":" expr [ "cs" | "ds" | "s" | "m" ] [ ";" ] (* Sleep. *)
        | "<!" (* Show dialog. *)
        | "!>" (* Hide dialog.*)
        | "<*" (* Freeze player. *)
        | "*>" (* Unfreeze player. *)
        | ";" (* No operation. *)
        ;

(* Statements beginning with a string literal: *)
string_stmt = LITERAL_STRING
            ( ":" (* Display dialog name. *)
            | "~" LITERAL_STRING [ ";" ] (* Find actor path. *)
            | "~>" LITERAL_STRING [ ";" ] (* Run actor paths. *)
            | "->" LITERAL_STRING [ ";" ] (* Run actor paths and await. *)
            | ">" [ expr | "right" | "down" | "left" | "up" ] [ ";" ]
            | [ ";" ] (* Display dialog message *)
            );

expr = expr_assignment ;

(* Expression precedence levels from low to high: *)
expr_assignment  = expr_logical_or [ "=" expr_assignment ] ;
expr_logical_or  = expr_logical_and { ( "or" | "||" ) expr_logical_and } ;
expr_logical_and = expr_logical_not { ( "and" | "&&" ) expr_logical_not } ;
expr_logical_not = ( "not" | "!" ) expr_logical_not | expr_equality ;
expr_equality    = expr_comparison { ( "!=" | "==" ) expr_comparison } ;
expr_comparison  = expr_sum { ( "<" | "<=" | ">" | ">=" ) expr_sum } ;
expr_sum         = expr_term { ( "+" | "-" ) expr_term } ;
expr_term        = expr_signed { "*" expr_signed } ;
expr_signed      = { "+" } ( "-" expr_signed | expr_primary ) ;
expr_primary     = "(" expr ")" | IDENTIFIER [ "." IDENTIFIER ] | LITERAL_INT | "false" | "true" | "IS_REPEAT" ;
