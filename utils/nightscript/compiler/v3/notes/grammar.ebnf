(* NightScript Version 3 Reference Grammar *)

module = { include }, { stmt }, EOF ;

include = "include", expr_primary_str, ";" ;

stmt = (
	stmt_func | stmt_block | stmt_if | stmt_while | stmt_do | stmt_menu |
	stmt_option | stmt_break | stmt_continue | stmt_const | stmt_var |
	stmt_return | stmt_expr
) ;

stmt_func = (
	"func", expr_primary_identifier,
	"(", [ expr_primary_identifier, { ",", expr_primary_identifier } ], ")",
	stmt
) ;
stmt_block = "{", { stmt }, "}" ;
stmt_if = "if", expr_paren, stmt, [ "else", stmt ] ;
stmt_while = "while", expr_paren, stmt ;
stmt_do = "do", stmt, "while", expr_paren, ";" ;
stmt_menu = "menu", stmt ;
stmt_option = "option", expr_paren, stmt ;
stmt_break = "break", ";" ;
stmt_continue = "continue", ";" ;
stmt_const = "const", expr_primary_identifier, "=", expr, ";" ;
stmt_var = "var", expr_primary_identifier, "=", expr, ";" ;
stmt_return = "return", [ expr ], ";" ;
stmt_expr = expr, ";" ;

expr_paren = "(", expr, ")" ;
expr = expr_assignment ;

expr_assignment = expr_logical_or, [ "=", expr_assignment ] ;
expr_logical_or = expr_logical_and, { "||", expr_logical_and } ;
expr_logical_and = expr_eager_or, { "&&", expr_eager_or } ;
expr_eager_or = expr_eager_and, { "|", expr_eager_and } ;
expr_eager_and = expr_not, { "&", expr_not } ;
expr_not = "!", expr_not | expr_equality ;
expr_equality = expr_comparison, { ( "!=" | "==" ), expr_comparison } ;
expr_comparison = expr_sum, { ( "<" | "<=" | ">" | ">=" ), expr_sum } ;
expr_sum = expr_term, { ( "+" | "-" ), expr_term } ;
expr_term = expr_sign, { "*", expr_sign } ;
expr_sign = ( "+" | "-" ), expr_sign | expr_call ;
expr_call = expr_primary, { "(", [ expr, { ",", expr } ], ")" } ;
expr_primary = (
	expr_paren | expr_primary_int | expr_primary_str | expr_primary_identifier
) ;

expr_primary_int = LITERAL_INT ;
expr_primary_str = LITERAL_STR ;
expr_primary_identifier = IDENTIFIER ;
